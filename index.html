<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glitch Matrix Prototype</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500&family=Orbitron:wght@400;600;700&family=Space+Grotesk:wght@500;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            color-scheme: dark;
            --bg-0: #05080b;
            --bg-1: #0a1118;
            --bg-2: #0f1a25;
            --glow: #00f0ff;
            --glow-soft: rgba(0, 240, 255, 0.2);
            --accent: #ff4f7b;
            --accent-soft: rgba(255, 79, 123, 0.2);
            --text: #e8f6ff;
            --muted: #8fb0c4;
            --frame-bg: rgba(6, 12, 18, 0.82);
            --frame-border: rgba(0, 240, 255, 0.35);
        }

        @keyframes gradientFlow {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            font-family: "IBM Plex Mono", "Courier New", monospace;
            color: var(--text);
            background:
                radial-gradient(circle at 15% 15%, rgba(0, 240, 255, 0.12), transparent 45%),
                radial-gradient(circle at 85% 10%, rgba(255, 79, 123, 0.14), transparent 40%),
                radial-gradient(circle at 60% 80%, rgba(0, 140, 255, 0.12), transparent 45%),
                linear-gradient(180deg, var(--bg-0) 0%, var(--bg-1) 40%, var(--bg-2) 100%);
            overflow-x: hidden;
        }

        #hero {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0 10vw;
            z-index: 3;
            pointer-events: none;
        }

        .hero-inner {
            max-width: 1100px;
        }

        .hero-title {
            font-family: "Space Grotesk", "Trebuchet MS", sans-serif;
            font-size: clamp(2.2rem, 4.4vw, 4.6rem);
            line-height: 1.1;
            margin: 0 0 16px;
            background: linear-gradient(90deg, #33ffc5, #33ccff, #3366ff);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
            animation: gradientFlow 6s ease infinite;
        }

        .hero-subtitle {
            margin: 0;
            font-size: clamp(1rem, 1.6vw, 1.4rem);
            letter-spacing: 0.02em;
            color: var(--muted);
        }

        #scroll-hint {
            position: fixed;
            left: 50%;
            bottom: 28px;
            transform: translateX(-50%);
            z-index: 3;
            text-transform: uppercase;
            letter-spacing: 0.24em;
            font-size: 0.72rem;
            color: var(--muted);
            opacity: 0.85;
            pointer-events: none;
        }

        #scroll-hint span {
            color: var(--glow);
        }

        #intersection-hint {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            font-family: "Orbitron", "Trebuchet MS", sans-serif;
            font-size: clamp(0.9rem, 1.8vw, 1.2rem);
            letter-spacing: 0.12em;
            color: var(--glow);
            text-shadow: 0 0 15px rgba(0, 240, 255, 0.6);
            opacity: 0;
            pointer-events: none;
            text-align: center;
            max-width: 90vw;
            transition: opacity 0.5s ease;
        }

        #intersection-hint.visible {
            opacity: 1;
        }

        #typed-text::after {
            content: '|';
            animation: blink 1s infinite;
        }

        #typed-text.typing-complete::after {
            content: '';
        }

        @keyframes blink {

            0%,
            50% {
                opacity: 1;
            }

            51%,
            100% {
                opacity: 0;
            }
        }

        #intro-dim {
            position: fixed;
            inset: 0;
            background: #010206;
            opacity: 0;
            pointer-events: none;
            z-index: 2;
        }

        #viewport {
            position: fixed;
            inset: 0;
            perspective: 1000px;
            overflow: hidden;
        }

        #scene {
            position: absolute;
            inset: -25vh -10vw;
            transform-style: preserve-3d;
        }

        #grid-plane {
            position: absolute;
            width: 200vw;
            height: 200vh;
            top: 50%;
            left: -50vw;
            background-image:
                linear-gradient(transparent 95%, rgba(0, 240, 255, 0.08) 98%),
                linear-gradient(90deg, transparent 95%, rgba(0, 240, 255, 0.08) 98%);
            background-size: 80px 80px;
            transform: translate3d(0, 200px, -5000px) rotateX(86deg);
            opacity: 0.6;
            pointer-events: none;
        }

        #voxel-field,
        #posts {
            position: absolute;
            inset: 0;
            transform-style: preserve-3d;
        }

        .voxel {
            position: absolute;
            width: 10px;
            height: 10px;
            background: rgba(0, 240, 255, 0.15);
            box-shadow: 0 0 12px rgba(0, 240, 255, 0.45);
            transform-style: preserve-3d;
            animation: voxel-flicker 3s steps(2, end) infinite;
            opacity: 0.7;
        }

        .post-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            width: min(88vw, 640px);
            transform: translate3d(calc(-50% + var(--x)), calc(-50% + var(--y)), var(--z)) rotateY(var(--rotateY, 0deg));
            transform-style: preserve-3d;
            transition: opacity 0.3s ease, filter 0.3s ease;
            pointer-events: auto;
        }

        .post-frame.intersection-frame {
            width: min(75vw, 450px);
        }

        .post-frame::before,
        .post-frame::after {
            content: "";
            position: absolute;
            inset: -8px;
            border: 1px solid transparent;
            pointer-events: none;
            animation: frame-glitch 6s steps(2, end) infinite;
        }

        .post-frame::before {
            border-color: rgba(0, 240, 255, 0.35);
            transform: translate3d(-2px, 0, 10px);
            opacity: 0.7;
        }

        .post-frame::after {
            border-color: rgba(255, 79, 123, 0.3);
            transform: translate3d(2px, 0, 6px);
            opacity: 0.5;
        }

        .frame-inner {
            position: relative;
            padding: 22px 26px;
            background: var(--frame-bg);
            border: 1px solid var(--frame-border);
            backdrop-filter: blur(8px);
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.4);
        }

        .frame-index {
            font-family: "Orbitron", "Trebuchet MS", sans-serif;
            font-size: 0.9rem;
            letter-spacing: 0.2em;
            color: var(--glow);
            margin-bottom: 6px;
        }

        .frame-title {
            font-family: "Orbitron", "Trebuchet MS", sans-serif;
            font-size: 1.85rem;
            margin: 0 0 10px;
            text-shadow: 0 0 12px rgba(0, 240, 255, 0.35);
        }

        .frame-meta {
            font-size: 0.85rem;
            color: var(--muted);
            margin-bottom: 12px;
        }

        .frame-body {
            font-size: 1.02rem;
            line-height: 1.6;
            margin: 0 0 14px;
        }

        .frame-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .frame-tag {
            padding: 4px 10px;
            border: 1px solid rgba(0, 240, 255, 0.35);
            border-radius: 999px;
            font-size: 0.75rem;
            color: var(--glow);
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .post-frame.lab-assignments .frame-inner {
            border-color: var(--accent);
        }

        .post-frame.lab-assignments::before {
            border-color: rgba(255, 79, 123, 0.5);
        }

        .post-frame.lab-assignments::after {
            border-color: rgba(255, 79, 123, 0.35);
        }

        .post-frame.lab-assignments .frame-index,
        .post-frame.lab-assignments .frame-title {
            color: var(--accent);
            text-shadow: 0 0 12px rgba(255, 79, 123, 0.45);
        }

        .post-frame.lab-assignments .frame-tag {
            border-color: rgba(255, 79, 123, 0.5);
            color: var(--accent);
        }

        .post-frame.lecture-assignments .frame-inner {
            border-color: rgba(147, 112, 219, 0.5);
        }

        .post-frame.lecture-assignments::before {
            border-color: rgba(138, 43, 226, 0.5);
        }

        .post-frame.lecture-assignments::after {
            border-color: rgba(147, 112, 219, 0.35);
        }

        .post-frame.lecture-assignments .frame-index,
        .post-frame.lecture-assignments .frame-title {
            color: #9370db;
            text-shadow: 0 0 12px rgba(138, 43, 226, 0.45);
        }

        .post-frame.lecture-assignments .frame-tag {
            border-color: rgba(147, 112, 219, 0.5);
            color: #9370db;
        }

        .post-frame {
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .post-frame:hover {
            transform: translate3d(calc(-50% + var(--x)), calc(-50% + var(--y)), calc(var(--z) + 20px)) rotateY(var(--rotateY, 0deg));
        }

        #scanlines,
        #noise,
        #chromatic,
        #vignette {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 4;
        }

        #scanlines {
            background: repeating-linear-gradient(180deg,
                    rgba(0, 0, 0, 0.15) 0px,
                    rgba(0, 0, 0, 0.15) 1px,
                    transparent 2px,
                    transparent 4px);
            mix-blend-mode: soft-light;
            opacity: 0.5;
            animation: scanline 8s linear infinite;
        }

        #noise {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='0.25'/%3E%3C/svg%3E");
            opacity: 0.18;
            mix-blend-mode: soft-light;
            animation: noise 1s steps(2, end) infinite;
        }

        #chromatic {
            background: linear-gradient(90deg, rgba(255, 79, 123, 0.12), rgba(0, 240, 255, 0.1));
            mix-blend-mode: screen;
            opacity: 0.35;
            animation: chroma 10s ease-in-out infinite;
        }

        #vignette {
            background: radial-gradient(circle at center, transparent 40%, rgba(2, 5, 8, 0.85) 100%);
        }

        #scroll-track {
            height: 520vh;
        }

        @keyframes voxel-flicker {

            0%,
            100% {
                opacity: 0.7;
            }

            40% {
                opacity: 0.2;
            }

            60% {
                opacity: 0.9;
            }
        }

        @keyframes frame-glitch {

            0%,
            100% {
                opacity: 0.35;
                transform: translate3d(2px, 0, 8px);
            }

            45% {
                opacity: 0.7;
                transform: translate3d(-3px, 1px, 12px);
            }

            60% {
                opacity: 0.2;
                transform: translate3d(1px, -1px, 4px);
            }
        }

        @keyframes scanline {
            0% {
                transform: translateY(-20%);
            }

            100% {
                transform: translateY(20%);
            }
        }

        @keyframes noise {

            0%,
            100% {
                transform: translate3d(0, 0, 0);
            }

            50% {
                transform: translate3d(-10px, 12px, 0);
            }
        }

        @keyframes chroma {

            0%,
            100% {
                opacity: 0.25;
            }

            50% {
                opacity: 0.45;
            }
        }

        @media (max-width: 720px) {
            #hero {
                padding: 0 8vw;
            }

            .hero-title {
                font-size: clamp(1.9rem, 7.2vw, 3.2rem);
            }

            .post-frame {
                width: min(92vw, 500px);
            }

            .frame-inner {
                padding: 18px 20px;
            }

            #scroll-hint {
                letter-spacing: 0.16em;
                font-size: 0.68rem;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation: none !important;
                transition: none !important;
            }
        }
    </style>
</head>

<body>
    <div id="hero">
        <div class="hero-inner">
            <h1 class="hero-title">Human-Computer Interaction for Mixed<br>Reality (CSC_5IG01_TP)</h1>
            <p class="hero-subtitle">Soheil Lotfi, Arsalan Masoudifard</p>
        </div>
    </div>
    <div id="scroll-hint">Scroll to move <span>forward</span></div>

    <div id="viewport">
        <div id="scene">
            <div id="grid-plane"></div>
            <div id="voxel-field"></div>
            <div id="posts"></div>
        </div>
    </div>

    <div id="intersection-hint">
        <span id="typed-text"></span>
    </div>

    <div id="scanlines"></div>
    <div id="noise"></div>
    <div id="chromatic"></div>
    <div id="vignette"></div>
    <div id="intro-dim"></div>
    <div id="scroll-track"></div>

    <canvas id="minimap"></canvas>

    <style>
        #minimap {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 150px;
            z-index: 100;
            pointer-events: none;
            opacity: 0.8;
        }
    </style>

    <script>
        const posts = [
            {
                title: "Projects",
                meta: "Main Track",
                body: "Explore our main project portfolio and research initiatives.",
                tags: ["projects", "main"],
                isProjects: true
            },
            {
                title: "Lab Assignments",
                meta: "Lab Track",
                body: "View lab sessions, experiments, and hands-on assignments.",
                tags: ["lab", "assignments"],
                isLabAssignments: true
            },
            {
                title: "Lecture Assignments",
                meta: "Lecture Track",
                body: "Access lecture materials, notes, and theoretical assignments.",
                tags: ["lecture", "theory"],
                isLectureAssignments: true
            },
            {
                title: "Lab 01: Sensor Calibration",
                meta: "Lab Session / Week 2",
                body: "Hands-on sensor calibration and drift correction experiments.",
                tags: ["lab", "sensors", "calibration"],
                isLabRoute: true
            },
            {
                title: "Entry 02: Latency Mirage",
                meta: "Lecture Notes / 2025.02",
                body: "Delayed perception folds into itself. The room repeats, but the data stays coherent.",
                tags: ["latency", "perception", "notes"]
            },
            {
                title: "Entry 03: Holo Console",
                meta: "Prototype / 2025.03",
                body: "A floating console surfaces in the noise. Controls stay sharp while the background jitters.",
                tags: ["ui", "prototype", "vr"]
            },
            {
                title: "Entry 04: Signal Ritual",
                meta: "Project Log / 2025.04",
                body: "Gesture-based inputs become ritual. Each frame locks in before dissolving into static.",
                tags: ["gesture", "ritual", "log"]
            },
            {
                title: "Entry 05: Archive Echo",
                meta: "Field Study / 2025.05",
                body: "Posts echo behind you as glowing traces. The matrix retains every sequence.",
                tags: ["archive", "echo", "field"]
            }
        ];

        const spacing = 2300;
        const scatterX = 220;
        const scatterY = 140;
        const postsEl = document.getElementById("posts");
        const voxelField = document.getElementById("voxel-field");
        const scrollTrack = document.getElementById("scroll-track");
        const scene = document.getElementById("scene");
        const hero = document.getElementById("hero");
        const scrollHint = document.getElementById("scroll-hint");
        const introDim = document.getElementById("intro-dim");
        const intersectionHint = document.getElementById("intersection-hint");
        const typedText = document.getElementById("typed-text");
        const minimap = document.getElementById("minimap");
        const ctx = minimap.getContext("2d");

        const totalDepth = (posts.length - 1) * spacing + 2800;
        const introDepth = 5400;
        scrollTrack.style.height = `${Math.max(520, posts.length * 140)}vh`;

        // Store world positions for the minimap
        const mapPoints = [];
        let mapBounds = { minX: 0, maxX: 0, minZ: -totalDepth, maxZ: introDepth };

        posts.forEach((post, index) => {
            const frame = document.createElement("article");
            frame.className = "post-frame";

            // Position intersection frames and routes
            let z, x, y, rotateY = 0;
            let mapX = 0; // Default map X
            let mapZ = 0; // Default map Z

            if (index === 0) {
                // Projects frame - CENTER of screen
                z = 0;
                x = 0;
                y = 0;
                frame.classList.add("intersection-frame");
                mapZ = 0;
            } else if (index === 1) {
                // Lab Assignments frame
                z = 200;
                x = 450;
                y = 0;
                rotateY = -45;
                frame.classList.add("lab-assignments", "intersection-frame");
                // Map to center (overlap with index 0 for "one dot" effect)
                mapX = 0; mapZ = 0;
            } else if (index === 2) {
                // Lecture Assignments frame
                z = 200;
                x = -450;
                y = 0;
                rotateY = 45;
                frame.classList.add("lecture-assignments", "intersection-frame");
                // Map to center
                mapX = 0; mapZ = 0;
            } else if (index === 3) {
                // Lab 01 - Branch
                z = -spacing * Math.cos(Math.PI / 4);
                x = 600 + spacing * Math.sin(Math.PI / 4);
                y = 0;
                rotateY = -45;
                frame.classList.add("lab-assignments");
                // Keep actual position for map
                mapX = x;
                mapZ = z;
            } else {
                // Main Track
                z = -(index - 3) * spacing;
                x = (Math.random() * 2 - 1) * scatterX;
                y = (Math.random() * 2 - 1) * scatterY;
                // Force align to center line on map
                mapX = 0;
                mapZ = z;
            }

            // Only add unique points or simplified representation
            // For indices 0, 1, 2, they map to (0,0). We can just add one of them or all (they overlap).
            // Let's add all to track them, but visually they are one.
            mapPoints.push({ x: mapX, z: mapZ, type: (index <= 2) ? 'node' : 'post', originalIndex: index });

            // Update bounds for map (using symmetric X to keep 0 centered)
            const absX = Math.abs(mapX);
            mapBounds.maxX = Math.max(mapBounds.maxX, absX);
            // minZ is already tracked via loop logic mostly, but let's ensure
            mapBounds.minZ = Math.min(mapBounds.minZ, mapZ);

            frame.style.setProperty("--x", `${x}px`);
            frame.style.setProperty("--y", `${y}px`);
            frame.style.setProperty("--z", `${z}px`);
            frame.style.setProperty("--rotateY", `${rotateY}deg`);
            frame.dataset.z = z;

            frame.innerHTML = `
                <div class="frame-inner">
                    <div class="frame-index">FRAME ${String(index + 1).padStart(2, "0")}</div>
                    <h2 class="frame-title">${post.title}</h2>
                    <div class="frame-meta">${post.meta}</div>
                    <p class="frame-body">${post.body}</p>
                    <div class="frame-tags">
                        ${post.tags.map((tag) => `<span class="frame-tag">${tag}</span>`).join("")}
                    </div>
                </div>
            `;

            // Add click handlers
            if (post.isProjects) {
                frame.addEventListener("click", () => {
                    targetRotationY = 0; // Rotate back to center
                    targetTranslateX = 0; // Move back to center
                });
                frame.style.pointerEvents = "auto";
            } else if (post.isLabAssignments) {
                frame.addEventListener("click", () => {
                    targetRotationY = 45; // Rotate 45 degrees to the right
                    targetTranslateX = 350; // Move camera to the right (adjust this value)
                });
                frame.style.pointerEvents = "auto";
            } else if (post.isLectureAssignments) {
                frame.addEventListener("click", () => {
                    targetRotationY = -45; // Rotate 45 degrees to the left
                    targetTranslateX = -350; // Move camera to the left (adjust this value)
                });
                frame.style.pointerEvents = "auto";
            }

        postsEl.appendChild(frame);
    });

        // End main track at the last main-track point (x === 0).
        const mainTrackPoints = mapPoints.filter((point) => point.x === 0);
        if (mainTrackPoints.length > 0) {
            mapBounds.minZ = Math.min(...mainTrackPoints.map((point) => point.z));
        }

        // Setup Minimap
        minimap.width = 400; // Double resolution for crispness
        minimap.height = 300;

        function drawMinimap() {
            ctx.clearRect(0, 0, minimap.width, minimap.height);

            const padding = 40;
            const availableWidth = minimap.width - padding * 2;
            const availableHeight = minimap.height - padding * 2;

            // Calculate ranges
            // Z Range: roughly 15000 units (5400 start to -9200 end)
            // X Range: roughly 4500 units (+/- 2226)
            const rangeZ = mapBounds.maxZ - mapBounds.minZ;
            const rangeX = Math.max(mapBounds.maxX * 2, 2000); // Ensure minimal width

            // Calculate Scale Factors for each dimension
            const scaleZ = availableHeight / rangeZ;
            const scaleX = availableWidth / rangeX;

            // UNIFIED SCALE: Use the smaller scale to fit both dimensions within the box
            // This preserves the aspect ratio (angles).
            // Since the world is very long (Z) and narrow (X), scaleZ will likely be the limiting factor.
            const scale = Math.min(scaleZ, scaleX);

            function getMapY(worldZ) {
                // Map worldZ to canvas Y
                // maxZ (Start) -> Bottom
                // minZ (End) -> Top
                // Formula: BottomY - (distance_from_start * scale)
                const distanceFromStart = mapBounds.maxZ - worldZ;
                return (minimap.height - padding) - (distanceFromStart * scale);
            }

            function getMapX(worldX) {
                // Map worldX to canvas X
                // 0 -> Center
                const center = minimap.width / 2;
                return center + (worldX * scale);
            }

            // Draw Connection Lines
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0, 240, 255, 0.2)';
            ctx.lineWidth = 3;

            // Main Track (Index 0 -> End)
            // Just draw a line from (0, maxZ) to (0, minZ)
            ctx.moveTo(getMapX(0), getMapY(mapBounds.maxZ)); // Start
            ctx.lineTo(getMapX(0), getMapY(mapBounds.minZ)); // End
            ctx.stroke();

            // Lab Branch Line
            // From (0,0) (Intersection) to Frame 3 Position
            const labFrame = mapPoints.find(p => p.originalIndex === 3);
            if (labFrame) {
                ctx.beginPath();
                ctx.moveTo(getMapX(0), getMapY(0)); // Intersection point
                ctx.lineTo(getMapX(labFrame.x), getMapY(labFrame.z));
                ctx.strokeStyle = 'rgba(255, 79, 123, 0.4)';
                ctx.stroke();
            }

            // Draw Points
            mapPoints.forEach((p, i) => {
                if ((p.originalIndex === 1 || p.originalIndex === 2)) return;

                const mx = getMapX(p.x);
                const my = getMapY(p.z);

                ctx.beginPath();
                ctx.arc(mx, my, p.type === 'node' ? 3 : 5, 0, Math.PI * 2);
                ctx.fillStyle = p.originalIndex === 3 ? '#ff4f7b' : (p.type === 'node' ? '#00f0ff' : 'rgba(143, 176, 196, 0.5)');
                ctx.fill();
            });

            // Draw Player
            const yRadian = -currentRotationY * Math.PI / 180;
            const forward = -currentZ;

            const playerWorldZ = forward * Math.cos(yRadian);;
            const playerWorldX = currentTranslateX + forward * Math.sin(yRadian);;

            const px = getMapX(playerWorldX);
            const py = getMapY(playerWorldZ);

            ctx.beginPath();
            ctx.arc(px, py, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#ff4f7b';
            ctx.fill();
            ctx.shadowBlur = 0;

            // Start Point (Reference)
            const sx = getMapX(0);
            const sy = getMapY(introDepth);
            ctx.beginPath();
            ctx.moveTo(sx - 45, sy);
            ctx.lineTo(sx + 45, sy);
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        console.log("--- Frame Layout Debug ---");
        document.querySelectorAll('.post-frame').forEach((frame, index) => {
            const x = frame.style.getPropertyValue('--x');
            const y = frame.style.getPropertyValue('--y');
            const z = frame.style.getPropertyValue('--z');
            const type = frame.classList.contains('intersection-frame') ? 'Intersection' : 'Post';
            console.log(`Frame ${index} (${type}): X=${x}, Y=${y}, Z=${z}`);
        });

        for (let i = 0; i < 160; i += 1) {
            const voxel = document.createElement("span");
            voxel.className = "voxel";
            const x = (Math.random() * 2 - 1) * 1200;
            const y = (Math.random() * 2 - 1) * 800;
            const z = -Math.random() * (totalDepth + 3000);
            voxel.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
            voxel.style.animationDelay = `${Math.random() * 2}s`;
            voxelField.appendChild(voxel);
        }

        let targetZ = -introDepth;
        let currentZ = -introDepth;
        let scrollProgress = 0;
        let tiltX = 0;
        let tiltY = 0;
        let targetRotationY = 0;
        let currentRotationY = 0;
        let targetTranslateX = 0;
        let currentTranslateX = 0;
        let hasReachedIntersection = false;
        let isTyping = false;

        console.log(`Starting Camera Position: X=${currentTranslateX}, Y=0, Z=${currentZ}`);

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        // Typewriter effect function
        function typeWriter(text, element, speed = 50) {
            if (isTyping) return;
            isTyping = true;
            let i = 0;
            element.textContent = '';

            function type() {
                if (i < text.length) {
                    element.textContent += text.charAt(i);
                    i++;
                    setTimeout(type, speed);
                } else {
                    element.classList.add('typing-complete');
                    setTimeout(() => {
                        intersectionHint.classList.remove('visible');
                    }, 4000); // Hide after 4 seconds
                }
            }
            type();
        }

        function updateFrameVisibility(depth) {
            const frames = document.querySelectorAll(".post-frame");
            frames.forEach((frame) => {
                const z = parseFloat(frame.dataset.z);
                const distance = Math.abs(z + depth);
                const fade = 1 - distance / 2800;
                const opacity = clamp(fade, 0.05, 1);
                frame.style.opacity = opacity.toFixed(2);
                frame.style.filter = `blur(${clamp((1 - opacity) * 3.5, 0, 3)}px)`;
            });
        }

        

        function onScroll() {
            const maxScroll = document.body.scrollHeight - window.innerHeight;
            scrollProgress = maxScroll > 0 ? window.scrollY / maxScroll : 0;
            targetZ = scrollProgress * (totalDepth + introDepth) - introDepth;
            console.log(`Current Position (Target): Z=${targetZ.toFixed(2)}, Scroll=${scrollProgress.toFixed(3)}`);
        }

        function onPointerMove(event) {
            const nx = (event.clientX / window.innerWidth) - 0.5;
            const ny = (event.clientY / window.innerHeight) - 0.5;
            tiltY = nx * 6;
            tiltX = -ny * 4;
        }

        function animate() {
            currentZ += (targetZ - currentZ) * 0.08;
            currentRotationY += (targetRotationY - currentRotationY) * 0.08;
            currentTranslateX += (targetTranslateX - currentTranslateX) * 0.08;
            scene.style.transform = `translate3d(${-currentTranslateX}px, 0, ${currentZ}px) rotateX(${tiltX}deg) rotateY(${tiltY + currentRotationY}deg)`;
            updateFrameVisibility(currentZ);

            // Detect intersection arrival (when currentZ is close to 0, meaning we've reached the frames)
            if (!hasReachedIntersection && currentZ >= -500 && currentZ <= 500) {
                hasReachedIntersection = true;
                intersectionHint.classList.add('visible');
                typeWriter('> SELECT TRACK _ Navigate your pathway through the matrix', typedText, 60);
            }

            const introProgress = clamp((currentZ + introDepth) / introDepth, 0, 1);
            const heroOpacity = clamp(1 - introProgress * 2, 0, 1);
            if (hero) {
                hero.style.opacity = heroOpacity.toFixed(2);
                hero.style.transform = `translate3d(0, ${introProgress * -50}px, 0)`;
            }
            if (scrollHint) {
                scrollHint.style.opacity = clamp(heroOpacity * 0.9, 0, 0.9).toFixed(2);
            }
            if (introDim) {
                const dimOpacity = clamp(0.55 * (1 - introProgress), 0, 0.55);
                introDim.style.opacity = dimOpacity.toFixed(2);
            }
            drawMinimap();
            requestAnimationFrame(animate);
        }

        window.addEventListener("scroll", onScroll, { passive: true });
        window.addEventListener("pointermove", onPointerMove);
        window.addEventListener("resize", onScroll);

        onScroll();
        animate();
    </script>
</body>

</html>
